.\" Automatically generated by Pod::Man 4.07 (Pod::Simple 3.32)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Inotify2 3pm"
.TH Inotify2 3pm "2019-07-01" "perl v5.24.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Linux::Inotify2 \- scalable directory/file change notification
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SS "Callback Interface"
.IX Subsection "Callback Interface"
.Vb 1
\& use Linux::Inotify2;
\&
\& # create a new object
\& my $inotify = new Linux::Inotify2
\&    or die "unable to create new inotify object: $!";
\& 
\& # add watchers
\& $inotify\->watch ("/etc/passwd", IN_ACCESS, sub {
\&    my $e = shift;
\&    my $name = $e\->fullname;
\&    print "$name was accessed\en" if $e\->IN_ACCESS;
\&    print "$name is no longer mounted\en" if $e\->IN_UNMOUNT;
\&    print "$name is gone\en" if $e\->IN_IGNORED;
\&    print "events for $name have been lost\en" if $e\->IN_Q_OVERFLOW;
\& 
\&    # cancel this watcher: remove no further events
\&    $e\->w\->cancel;
\& });
\&
\& # integration into AnyEvent (works with EV, Glib, Tk, POE...)
\& my $inotify_w = AE::io $inotify\->fileno, 0, sub { $inotify\->poll };
\&
\& # manual event loop
\& $inotify\->poll while 1;
.Ve
.SS "Streaming Interface"
.IX Subsection "Streaming Interface"
.Vb 1
\& use Linux::Inotify2;
\&
\& # create a new object
\& my $inotify = new Linux::Inotify2
\&    or die "Unable to create new inotify object: $!";
\&
\& # create watch
\& $inotify\->watch ("/etc/passwd", IN_ACCESS)
\&    or die "watch creation failed";
\&
\& while () {
\&   my @events = $inotify\->read;
\&   printf "mask\et%d\en", $_\->mask foreach @events;
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements an interface to the Linux 2.6.13 and later Inotify
file/directory change notification system.
.PP
It has a number of advantages over the Linux::Inotify module:
.PP
.Vb 5
\&   \- it is portable (Linux::Inotify only works on x86)
\&   \- the equivalent of fullname works correctly
\&   \- it is better documented
\&   \- it has callback\-style interface, which is better suited for
\&     integration.
.Ve
.PP
As for the inotify \s-1API\s0 itself \- it is a very tricky, and somewhat
unreliable \s-1API.\s0 For a good overview of the challenges you might run into,
see this \s-1LWN\s0 article: <https://lwn.net/Articles/605128/>.
.SS "The Linux::Inotify2 Class"
.IX Subsection "The Linux::Inotify2 Class"
.ie n .IP "my $inotify = new Linux::Inotify2" 4
.el .IP "my \f(CW$inotify\fR = new Linux::Inotify2" 4
.IX Item "my $inotify = new Linux::Inotify2"
Create a new notify object and return it. A notify object is kind of a
container that stores watches on file system names and is responsible for
handling event data.
.Sp
On error, \f(CW\*(C`undef\*(C'\fR is returned and \f(CW$!\fR will be set accordingly. The
following errors are documented:
.Sp
.Vb 3
\& ENFILE   The system limit on the total number of file descriptors has been reached.
\& EMFILE   The user limit on the total number of inotify instances has been reached.
\& ENOMEM   Insufficient kernel memory is available.
.Ve
.Sp
Example:
.Sp
.Vb 2
\&   my $inotify = new Linux::Inotify2
\&      or die "Unable to create new inotify object: $!";
.Ve
.ie n .IP "$watch = $inotify\->watch ($name, $mask[, $cb])" 4
.el .IP "\f(CW$watch\fR = \f(CW$inotify\fR\->watch ($name, \f(CW$mask\fR[, \f(CW$cb\fR])" 4
.IX Item "$watch = $inotify->watch ($name, $mask[, $cb])"
Add a new watcher to the given notifier. The watcher will create events
on the pathname \f(CW$name\fR as given in \f(CW$mask\fR, which can be any of the
following constants (all exported by default) ORed together.
.Sp
\&\*(L"file\*(R" refers to any file system object in the watched object (always a
directory), that is files, directories, symlinks, device nodes etc., while
\&\*(L"object\*(R" refers to the object the watcher has been set on itself:
.Sp
.Vb 10
\& IN_ACCESS            object was accessed
\& IN_MODIFY            object was modified
\& IN_ATTRIB            object metadata changed
\& IN_CLOSE_WRITE       writable fd to file / to object was closed
\& IN_CLOSE_NOWRITE     readonly fd to file / to object closed
\& IN_OPEN              object was opened
\& IN_MOVED_FROM        file was moved from this object (directory)
\& IN_MOVED_TO          file was moved to this object (directory)
\& IN_CREATE            file was created in this object (directory)
\& IN_DELETE            file was deleted from this object (directory)
\& IN_DELETE_SELF       object itself was deleted
\& IN_MOVE_SELF         object itself was moved
\& IN_ALL_EVENTS        all of the above events
\&
\& IN_ONESHOT           only send event once
\& IN_ONLYDIR           only watch the path if it is a directory
\& IN_DONT_FOLLOW       don\*(Aqt follow a sym link (Linux 2.6.15+)
\& IN_MASK_ADD          not supported with the current version of this module
\&
\& IN_CLOSE             same as IN_CLOSE_WRITE | IN_CLOSE_NOWRITE
\& IN_MOVE              same as IN_MOVED_FROM | IN_MOVED_TO
.Ve
.Sp
\&\f(CW$cb\fR is a perl code reference that, if given, is called for each
event. It receives a \f(CW\*(C`Linux::Inotify2::Event\*(C'\fR object.
.Sp
The returned \f(CW$watch\fR object is of class \f(CW\*(C`Linux::Inotify2::Watch\*(C'\fR.
.Sp
On error, \f(CW\*(C`undef\*(C'\fR is returned and \f(CW$!\fR will be set accordingly. The
following errors are documented:
.Sp
.Vb 5
\& EBADF    The given file descriptor is not valid.
\& EINVAL   The given event mask contains no legal events.
\& ENOMEM   Insufficient kernel memory was available.
\& ENOSPC   The user limit on the total number of inotify watches was reached or the kernel failed to allocate a needed resource.
\& EACCESS  Read access to the given file is not permitted.
.Ve
.Sp
Example, show when \f(CW\*(C`/etc/passwd\*(C'\fR gets accessed and/or modified once:
.Sp
.Vb 6
\&   $inotify\->watch ("/etc/passwd", IN_ACCESS | IN_MODIFY, sub {
\&      my $e = shift;
\&      print "$e\->{w}{name} was accessed\en" if $e\->IN_ACCESS;
\&      print "$e\->{w}{name} was modified\en" if $e\->IN_MODIFY;
\&      print "$e\->{w}{name} is no longer mounted\en" if $e\->IN_UNMOUNT;
\&      print "events for $e\->{w}{name} have been lost\en" if $e\->IN_Q_OVERFLOW;
\&
\&      $e\->w\->cancel;
\&   });
.Ve
.ie n .IP "$inotify\->fileno" 4
.el .IP "\f(CW$inotify\fR\->fileno" 4
.IX Item "$inotify->fileno"
Returns the file descriptor for this notify object. When in non-blocking
mode, you are responsible for calling the \f(CW\*(C`poll\*(C'\fR method when this file
descriptor becomes ready for reading.
.ie n .IP "$inotify\->blocking ($blocking)" 4
.el .IP "\f(CW$inotify\fR\->blocking ($blocking)" 4
.IX Item "$inotify->blocking ($blocking)"
Clears ($blocking true) or sets ($blocking false) the \f(CW\*(C`O_NONBLOCK\*(C'\fR flag on the file descriptor.
.ie n .IP "$count = $inotify\->poll" 4
.el .IP "\f(CW$count\fR = \f(CW$inotify\fR\->poll" 4
.IX Item "$count = $inotify->poll"
Reads events from the kernel and handles them. If the notify file
descriptor is blocking (the default), then this method waits for at least
one event. Otherwise it returns immediately when no pending events could
be read.
.Sp
Returns the count of events that have been handled (which can be \f(CW0\fR in case
events have been received but have been ignored or handled internally).
.Sp
Croaks when an error occurs.
.ie n .IP "@events = $inotify\->read" 4
.el .IP "\f(CW@events\fR = \f(CW$inotify\fR\->read" 4
.IX Item "@events = $inotify->read"
Reads events from the kernel. Blocks when the file descriptor is in
blocking mode (default) until any event arrives. Returns list of
\&\f(CW\*(C`Linux::Inotify2::Event\*(C'\fR objects or empty list if none (non-blocking
mode or events got ignored).
.Sp
Croaks on error.
.Sp
Normally you shouldn't use this function, but instead use watcher
callbacks and call \f(CW\*(C`\->poll\*(C'\fR.
.ie n .IP "$inotify\->on_overflow ($cb\->($ev))" 4
.el .IP "\f(CW$inotify\fR\->on_overflow ($cb\->($ev))" 4
.IX Item "$inotify->on_overflow ($cb->($ev))"
Sets the callback to be used for overflow handling
(default: \f(CW\*(C`undef\*(C'\fR): When \f(CW\*(C`read\*(C'\fR receives an event with \f(CW\*(C`IN_Q_OVERFLOW\*(C'\fR
set, it will invoke this callback with the event.
.Sp
When the callback is \f(CW\*(C`undef\*(C'\fR, then it broadcasts the event to all
registered watchers, i.e., \f(CW\*(C`undef\*(C'\fR is equivalent to:
.Sp
.Vb 1
\&   sub { $inotify\->broadcast ($_[0]) }
.Ve
.ie n .IP "$inotify\->broadcast ($ev)" 4
.el .IP "\f(CW$inotify\fR\->broadcast ($ev)" 4
.IX Item "$inotify->broadcast ($ev)"
Invokes all registered watcher callbacks and passes the given event to
them. Most useful in overflow handlers.
.SS "The Linux::Inotify2::Event Class"
.IX Subsection "The Linux::Inotify2::Event Class"
Objects of this class are handed as first argument to the watcher
callback. It has the following members and methods:
.ie n .IP "$event\->w" 4
.el .IP "\f(CW$event\fR\->w" 4
.IX Item "$event->w"
.PD 0
.ie n .IP "$event\->{w}" 4
.el .IP "\f(CW$event\fR\->{w}" 4
.IX Item "$event->{w}"
.PD
The watcher object for this event, if one is available. Generally, you cna
only rely on the value of this member inside watcher callbacks.
.ie n .IP "$event\->name" 4
.el .IP "\f(CW$event\fR\->name" 4
.IX Item "$event->name"
.PD 0
.ie n .IP "$event\->{name}" 4
.el .IP "\f(CW$event\fR\->{name}" 4
.IX Item "$event->{name}"
.PD
The path of the file system object, relative to the watched name.
.ie n .IP "$event\->fullname" 4
.el .IP "\f(CW$event\fR\->fullname" 4
.IX Item "$event->fullname"
Returns the \*(L"full\*(R" name of the relevant object, i.e. including the \f(CW\*(C`name\*(C'\fR
member of the watcher (if the watch object is on a directory and a
directory entry is affected), or simply the \f(CW\*(C`name\*(C'\fR member itself when the
object is the watch object itself.
.Sp
This call requires \f(CW\*(C`$event\->{w}\*(C'\fR to be valid, which is generally only
the case within watcher callbacks.
.ie n .IP "$event\->mask" 4
.el .IP "\f(CW$event\fR\->mask" 4
.IX Item "$event->mask"
.PD 0
.ie n .IP "$event\->{mask}" 4
.el .IP "\f(CW$event\fR\->{mask}" 4
.IX Item "$event->{mask}"
.PD
The received event mask. In addition to the events described for \f(CW\*(C`$inotify\->watch\*(C'\fR, the following flags (exported by default) can be set:
.Sp
.Vb 2
\& IN_ISDIR             event object is a directory
\& IN_Q_OVERFLOW        event queue overflowed
\&
\& # when any of the following flags are set,
\& # then watchers for this event are automatically canceled
\& IN_UNMOUNT           filesystem for watched object was unmounted
\& IN_IGNORED           file was ignored/is gone (no more events are delivered)
\& IN_ONESHOT           only one event was generated
\& IN_Q_OVERFLOW        queue overflow \- event might not be specific to a watcher
.Ve
.ie n .IP "$event\->IN_xxx" 4
.el .IP "\f(CW$event\fR\->IN_xxx" 4
.IX Item "$event->IN_xxx"
Returns a boolean that returns true if the event mask contains any events
specified by the mask. All of the \f(CW\*(C`IN_xxx\*(C'\fR constants can be used as
methods.
.ie n .IP "$event\->cookie" 4
.el .IP "\f(CW$event\fR\->cookie" 4
.IX Item "$event->cookie"
.PD 0
.ie n .IP "$event\->{cookie}" 4
.el .IP "\f(CW$event\fR\->{cookie}" 4
.IX Item "$event->{cookie}"
.PD
The event cookie to \*(L"synchronize two events\*(R". Normally zero, this value is
set when two events relating to the same file are generated. As far as I
know, this only happens for \f(CW\*(C`IN_MOVED_FROM\*(C'\fR and \f(CW\*(C`IN_MOVED_TO\*(C'\fR events, to
identify the old and new name of a file.
.Sp
Note that the inotify \s-1API\s0 makes it impossible to know whether there will
be a \f(CW\*(C`IN_MOVED_TO\*(C'\fR event \- you might receive only one of the events,
and even if you receive both, there might be any number of events in
between. The best approach seems to be to implement a small timeout
after \f(CW\*(C`IN_MOVED_FROM\*(C'\fR to see if a matching \f(CW\*(C`IN_MOVED_TO\*(C'\fR event will be
received \- 2ms seem to work relatively well.
.SS "The Linux::Inotify2::Watch Class"
.IX Subsection "The Linux::Inotify2::Watch Class"
Watcher objects are created by calling the \f(CW\*(C`watch\*(C'\fR method of a notifier.
.PP
It has the following members and methods:
.ie n .IP "$watch\->name" 4
.el .IP "\f(CW$watch\fR\->name" 4
.IX Item "$watch->name"
.PD 0
.ie n .IP "$watch\->{name}" 4
.el .IP "\f(CW$watch\fR\->{name}" 4
.IX Item "$watch->{name}"
.PD
The name as specified in the \f(CW\*(C`watch\*(C'\fR call. For the object itself, this is
the empty string.  For directory watches, this is the name of the entry
without leading path elements.
.ie n .IP "$watch\->mask" 4
.el .IP "\f(CW$watch\fR\->mask" 4
.IX Item "$watch->mask"
.PD 0
.ie n .IP "$watch\->{mask}" 4
.el .IP "\f(CW$watch\fR\->{mask}" 4
.IX Item "$watch->{mask}"
.PD
The mask as specified in the \f(CW\*(C`watch\*(C'\fR call.
.ie n .IP "$watch\->cb ([new callback])" 4
.el .IP "\f(CW$watch\fR\->cb ([new callback])" 4
.IX Item "$watch->cb ([new callback])"
.PD 0
.ie n .IP "$watch\->{cb}" 4
.el .IP "\f(CW$watch\fR\->{cb}" 4
.IX Item "$watch->{cb}"
.PD
The callback as specified in the \f(CW\*(C`watch\*(C'\fR call. Can optionally be changed.
.ie n .IP "$watch\->cancel" 4
.el .IP "\f(CW$watch\fR\->cancel" 4
.IX Item "$watch->cancel"
Cancels/removes this watcher. Future events, even if already queued queued,
will not be handled and resources will be freed.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
AnyEvent, Linux::Inotify.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Marc Lehmann <schmorp@schmorp.de>
\& http://home.schmorp.de/
.Ve
