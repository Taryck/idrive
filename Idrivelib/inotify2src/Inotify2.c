/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of Inotify2.xs. Do not edit this file, edit Inotify2.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Inotify2.xs"
#define PERL_NO_GET_CONTEXT

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include <unistd.h>
#include <fcntl.h>

#include <sys/inotify.h>

#line 22 "Inotify2.c"

XS(XS_Linux__Inotify2_inotify_init); /* prototype to pass -Wmissing-prototypes */
XS(XS_Linux__Inotify2_inotify_init)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Linux::Inotify2::inotify_init()");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = inotify_init();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Linux__Inotify2_inotify_close); /* prototype to pass -Wmissing-prototypes */
XS(XS_Linux__Inotify2_inotify_close)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Linux::Inotify2::inotify_close(fd)");
    {
	int	fd = (int)SvIV(ST(0));
#line 59 "Inotify2.xs"
        close (fd);
#line 51 "Inotify2.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Linux__Inotify2_inotify_add_watch); /* prototype to pass -Wmissing-prototypes */
XS(XS_Linux__Inotify2_inotify_add_watch)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Linux::Inotify2::inotify_add_watch(fd, name, mask)");
    {
	int	RETVAL;
	dXSTARG;
	int	fd = (int)SvIV(ST(0));
	char *	name = (char *)SvPV_nolen(ST(1));
	U32	mask = (unsigned long)SvUV(ST(2));

	RETVAL = inotify_add_watch(fd, name, mask);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Linux__Inotify2_inotify_rm_watch); /* prototype to pass -Wmissing-prototypes */
XS(XS_Linux__Inotify2_inotify_rm_watch)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Linux::Inotify2::inotify_rm_watch(fd, wd)");
    {
	int	RETVAL;
	dXSTARG;
	int	fd = (int)SvIV(ST(0));
	U32	wd = (unsigned long)SvUV(ST(1));

	RETVAL = inotify_rm_watch(fd, wd);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Linux__Inotify2_inotify_blocking); /* prototype to pass -Wmissing-prototypes */
XS(XS_Linux__Inotify2_inotify_blocking)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Linux::Inotify2::inotify_blocking(fd, blocking)");
    {
	int	RETVAL;
	dXSTARG;
	int	fd = (int)SvIV(ST(0));
	I32	blocking = (I32)SvIV(ST(1));
#line 70 "Inotify2.xs"
        fcntl (fd, F_SETFL, blocking ? 0 : O_NONBLOCK);
#line 109 "Inotify2.c"
    }
    XSRETURN(1);
}


XS(XS_Linux__Inotify2_inotify_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Linux__Inotify2_inotify_read)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: Linux::Inotify2::inotify_read(fd, size= 8192)");
    SP -= items;
    {
	int	fd = (int)SvIV(ST(0));
	int	size;

	if (items < 2)
	    size = 8192;
	else {
	    size = (int)SvIV(ST(1));
	}
#line 75 "Inotify2.xs"
{
	char buf [size], *cur, *end;
        int got = read (fd, buf, size);

        if (got < 0)
          if (errno != EAGAIN && errno != EINTR)
            croak ("Linux::Inotify2: read error while reading events");
          else
            XSRETURN_EMPTY;

        cur = buf;
        end = buf + got;

        while (cur < end)
          {
            struct inotify_event *ev = (struct inotify_event *)cur;
            cur += sizeof (struct inotify_event) + ev->len;

            while (ev->len > 0 && !ev->name [ev->len - 1])
              --ev->len;

            HV *hv = newHV ();
            hv_store (hv, "wd",     sizeof ("wd")     - 1, newSViv (ev->wd), 0);
            hv_store (hv, "mask",   sizeof ("mask")   - 1, newSViv (ev->mask), 0);
            hv_store (hv, "cookie", sizeof ("cookie") - 1, newSViv (ev->cookie), 0);
            hv_store (hv, "name",   sizeof ("name")   - 1, newSVpvn (ev->name, ev->len), 0);

            XPUSHs (sv_2mortal (newRV_noinc ((SV *)hv)));
          }
}
#line 162 "Inotify2.c"
	PUTBACK;
	return;
    }
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Linux__Inotify2); /* prototype to pass -Wmissing-prototypes */
XS(boot_Linux__Inotify2)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXSproto("Linux::Inotify2::inotify_init", XS_Linux__Inotify2_inotify_init, file, "");
        newXSproto("Linux::Inotify2::inotify_close", XS_Linux__Inotify2_inotify_close, file, "$");
        newXSproto("Linux::Inotify2::inotify_add_watch", XS_Linux__Inotify2_inotify_add_watch, file, "$$$");
        newXSproto("Linux::Inotify2::inotify_rm_watch", XS_Linux__Inotify2_inotify_rm_watch, file, "$$");
        newXSproto("Linux::Inotify2::inotify_blocking", XS_Linux__Inotify2_inotify_blocking, file, "$$");
        newXSproto("Linux::Inotify2::inotify_read", XS_Linux__Inotify2_inotify_read, file, "$;$");

    /* Initialisation Section */

#line 17 "Inotify2.xs"
{
	HV *stash = GvSTASH (CvGV (cv));

        static const struct civ { const char *name; IV iv; } *civ, const_iv[] = {
          { "IN_ACCESS"       , IN_ACCESS        },
          { "IN_MODIFY"       , IN_MODIFY        },
          { "IN_ATTRIB"       , IN_ATTRIB        },
          { "IN_CLOSE_WRITE"  , IN_CLOSE_WRITE	 },
          { "IN_CLOSE_NOWRITE", IN_CLOSE_NOWRITE },
          { "IN_OPEN"         , IN_OPEN          },
          { "IN_MOVED_FROM"   , IN_MOVED_FROM    },
          { "IN_MOVED_TO"     , IN_MOVED_TO      },
          { "IN_CREATE"       , IN_CREATE        },
          { "IN_DELETE"       , IN_DELETE        },
          { "IN_DELETE_SELF"  , IN_DELETE_SELF   },
          { "IN_MOVE_SELF"    , IN_MOVE_SELF     },
          { "IN_UNMOUNT"      , IN_UNMOUNT       },
          { "IN_Q_OVERFLOW"   , IN_Q_OVERFLOW    },
          { "IN_IGNORED"      , IN_IGNORED       },
          { "IN_CLOSE"        , IN_CLOSE         },
          { "IN_MOVE"         , IN_MOVE          },
          { "IN_ONLYDIR"      , IN_ONLYDIR       },
          { "IN_DONT_FOLLOW"  , IN_DONT_FOLLOW   },
          { "IN_MASK_ADD"     , IN_MASK_ADD      },
          { "IN_ISDIR"        , IN_ISDIR         },
          { "IN_ONESHOT"      , IN_ONESHOT       },
          { "IN_ALL_EVENTS"   , IN_ALL_EVENTS    },
	};

        for (civ = const_iv + sizeof (const_iv) / sizeof (const_iv [0]); civ > const_iv; civ--)
          newCONSTSUB (stash, (char *)civ[-1].name, newSViv (civ[-1].iv));
}

#line 225 "Inotify2.c"

    /* End of Initialisation Section */

    XSRETURN_YES;
}

